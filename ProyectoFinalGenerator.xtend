/*
 * generated by Xtext 2.25.0
 */
package edu.upb.lp.isc.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import edu.upb.lp.isc.proyectoFinal.PseudoInicio
import edu.upb.lp.isc.proyectoFinal.Arriba
import edu.upb.lp.isc.proyectoFinal.Expresion
import edu.upb.lp.isc.proyectoFinal.Entero
import edu.upb.lp.isc.proyectoFinal.OperacionesConEnteros
import edu.upb.lp.isc.proyectoFinal.Print
import edu.upb.lp.isc.proyectoFinal.CadenaTexto
import edu.upb.lp.isc.proyectoFinal.Booleano
import edu.upb.lp.isc.proyectoFinal.ExprListas
import edu.upb.lp.isc.proyectoFinal.OperacionesConStrings
import edu.upb.lp.isc.proyectoFinal.OperacionesConListas
import edu.upb.lp.isc.proyectoFinal.OperacionesConBoolean
import edu.upb.lp.isc.proyectoFinal.LlamadoDeFuncion
import edu.upb.lp.isc.proyectoFinal.OperaIf
import edu.upb.lp.isc.proyectoFinal.TipoDeDato
import edu.upb.lp.isc.proyectoFinal.OpEsUnString
import edu.upb.lp.isc.proyectoFinal.OpSubstring
import edu.upb.lp.isc.proyectoFinal.OpConcatenar
import edu.upb.lp.isc.proyectoFinal.OpLongitudStr
import edu.upb.lp.isc.proyectoFinal.OpEsBoolean
import edu.upb.lp.isc.proyectoFinal.OperaNot
import edu.upb.lp.isc.proyectoFinal.OperaAndOr
import edu.upb.lp.isc.proyectoFinal.OperaIntegersToBoolean

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ProyectoFinalGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
		val pr = resource.allContents.head as PseudoInicio
		fsa.generateFile(pr.name + '.sc', generatePseudoInicio(pr))
		
	}
	
	
	def generatePseudoInicio(PseudoInicio a) '''object «a.name» {
		«FOR d : a.arriba»«generateArriba(d)»«ENDFOR»
		«FOR e : a.abajo»«generateExpresion(e)»«ENDFOR»
	}'''
	
	
	def generateArriba(Arriba a) '''
	'''
	def generateExpresion(Expresion a) '''
	«IF a instanceof TipoDeDato» «generateTipoDeDato(a as TipoDeDato)»
	«ELSEIF a instanceof OperacionesConEnteros» «generateOperacionesConEnteros(a as OperacionesConEnteros)»
	«ELSEIF a instanceof OperacionesConStrings» «generateOperacionesConStrings(a as OperacionesConStrings)»
	«ELSEIF a instanceof OperacionesConBoolean» «generateOperacionesConBoolean(a as OperacionesConBoolean)»
	«ELSEIF a instanceof OperacionesConListas» «generateOperacionesConListas(a as OperacionesConListas)»
	«ELSEIF a instanceof LlamadoDeFuncion» «generateLlamadoDeFuncion(a as LlamadoDeFuncion)»
	«ELSEIF a instanceof OperaIf» «generateOperaIf(a as OperaIf)»
	«ELSEIF a instanceof Print» «generatePrint(a as Print)»
	«ENDIF»
	'''
	
	def generateTipoDeDato(TipoDeDato tipo) '''
	«IF tipo instanceof Entero» «generateEntero(tipo as Entero)»
	«ELSEIF tipo instanceof CadenaTexto» «generateCadenaTexto(tipo as CadenaTexto)»
	«ELSEIF tipo instanceof Booleano» «generateBooleano(tipo as Booleano)»
	«ELSEIF tipo instanceof ExprListas» «generateExprListas(tipo as ExprListas)»
	«ENDIF»
	'''
	
	def generateEntero(Entero entero) '''
	«val e = entero as Entero»
	«e.valor»
	'''
		
	def generateCadenaTexto(CadenaTexto texto)'''
	«val s = texto as CadenaTexto»
	"«s.str»"
	'''
	
	def generateBooleano(Booleano booleano)'''
	«val b = booleano as Booleano»
	«b.bool»
	'''
	
	def generateExprListas(ExprListas listas)'''
	List(«val lista = listas as ExprListas»«val nl = newLinkedList()»
	«FOR a: lista.expr»«{nl.add(generateExpresion(a as Expresion));" "}»
	«ENDFOR»«nl.join(", ")»)'''
	
	def generateOperacionesConEnteros(OperacionesConEnteros opints)'''
	(«val sumar = opints as OperacionesConEnteros»«val listaOperandos = newLinkedList()»
	«FOR a: sumar.sumando»«{listaOperandos.add(generateExpresion(a as Expresion));""}»
	«ENDFOR»«listaOperandos.join(sumar.sgnOp)»)'''
	
	def generateOperacionesConStrings(OperacionesConStrings opstrings)'''
	«IF opstrings instanceof OpEsUnString»«generateOpEsUnString(opstrings as OpEsUnString)»
	«ELSEIF opstrings instanceof OpSubstring»«generateOpSubstring(opstrings as OpSubstring)»
	«ELSEIF opstrings instanceof OpConcatenar»«generateOpConcatenar(opstrings as OpConcatenar)»
	«ELSEIF opstrings instanceof OpLongitudStr»«generateOpLongitudStr(opstrings as OpLongitudStr)»	
	«ENDIF»
	'''
	
	def generateOpEsUnString(OpEsUnString op) '''
	«val isstring = op as OpEsUnString»
	/* La Expresion dada 
	«IF isstring.expr instanceof CadenaTexto»
	si es tipo de String por lo que:
	«generateTipoDeDato(isstring.expr as TipoDeDato)» nos da como respuesta*/ true
	«ELSE»no es de tipo String, por lo que: */ 
	false
	«ENDIF»
	'''
	
	def generateOpSubstring(OpSubstring op) '''(
	«val substring = op as OpSubstring»
	«generateExpresion(substring.expr as Expresion)»
	«IF substring.second instanceof Entero».subSequence
	(«generateEntero(substring.first as Entero)», 
	«generateEntero(substring.second as Entero)»)
	«ELSE».substring(
	«generateEntero(substring.first as Entero)» 
	«ENDIF»
	)
    '''
	
	def generateOpConcatenar(OpConcatenar concatenar) '''
	((«val concat = concatenar as OpConcatenar»«val listaop = newLinkedList()»
	«FOR a: concat.str»«{listaop.add(generateExpresion(a as Expresion));""}»
	«ENDFOR»«listaop.join(").concat(")»))
	'''
	
	def generateOpLongitudStr(OpLongitudStr op)'''(
	«val longitud = op as OpLongitudStr»
	«generateExpresion(longitud.str as Expresion)».length())
	'''

	
	def generateOperacionesConBoolean(OperacionesConBoolean opbool)'''
	«IF opbool instanceof OpEsBoolean»«generateOpEsBoolean(opbool as OpEsBoolean)»
	«ELSEIF opbool instanceof OperaNot»«generateOperaNot(opbool as OperaNot)»
	«ELSEIF opbool instanceof OperaAndOr»«generateOperaAndOr(opbool as OperaAndOr)»	
	«ELSEIF opbool instanceof OperaIntegersToBoolean»«generateOperaIntegersToBoolean(opbool as OperaIntegersToBoolean)»
	«ENDIF»
	'''
	

	def generateOpEsBoolean(OpEsBoolean op) '''
	«val isbool = op as OpEsBoolean»
	«IF isbool.expr instanceof OpEsBoolean»
	/*«generateTipoDeDato(isbool.expr as TipoDeDato)»*/(true)
	«ELSE»(false)
	«ENDIF»
	'''
	
	def generateOperaNot(OperaNot not)'''(
	«val negar = not as OperaNot»
	!«generateExpresion(negar.expr as Expresion)»
	)'''
	
	def generateOperaAndOr(OperaAndOr op)'''(
	«val opbool = op as OperaAndOr»
	«IF opbool.op.equals("and")»
	«ELSEIF opbool.op.equals("or")»
	«ELSEIF opbool.op.equals("nor")»!(
	«ELSEIF opbool.op.equals("nand")»!(
	«ELSEIF opbool.op.equals("xor")»!(
	«ENDIF»
	«val listaOperandos = newLinkedList()»
	«FOR a: opbool.expr»«{listaOperandos.add(generateExpresion(a as Expresion));""}»
	«ENDFOR»
	«IF opbool.op.equals("and")»«listaOperandos.join(" && ")»
	«ELSEIF opbool.op.equals("or")»«listaOperandos.join(" || ")»
	«ELSEIF opbool.op.equals("nor")»«listaOperandos.join(" || ")»)
	«ELSEIF opbool.op.equals("nand")»«listaOperandos.join(" && ")»)
	«ELSEIF opbool.op.equals("xor")»«listaOperandos.join(" == ")»)
	«ENDIF»
	)'''
	
	def generateOperaIntegersToBoolean(OperaIntegersToBoolean op)'''(
	«val opbool = op as OperaIntegersToBoolean»
	«val listaOperandos = newLinkedList()»
	«FOR a: opbool.expr»«{listaOperandos.add(generateExpresion(a as Expresion));""}»
	«ENDFOR»
	«IF opbool.op.equals("=")»«listaOperandos.join("==")»
	«ELSE»«listaOperandos.join(opbool.op)»
	«ENDIF»)
	'''
	
	def generateOperaIf(OperaIf if1) ''''''
	
	def generatePrint(Print print) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	def generateOperacionesConListas(OperacionesConListas listas) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	def generateLlamadoDeFuncion(LlamadoDeFuncion funcion) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	
}
